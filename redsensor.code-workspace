#include <Wire.h>
#include <Adafruit_TCS34725.h>
#include <ColorConverter.h>

// 센서 객체 초기화 (기본 설정)
Adafruit_TCS34725 tcs = Adafruit_TCS34725(TCS34725_INTEGRATIONTIME_50MS, TCS34725_GAIN_4X);

// 색 변환 객체 생성
ColorConverter converter;

void setup() {
  Serial.begin(9600);
  Serial.println("TCS34725 Color Sensor - LAB Conversion Test");
  Serial.println("----------------------------------------");

  // 센서 시작 확인
  if (tcs.begin()) {
    Serial.println("Found sensor!");
  } else {
    Serial.println("No TCS34725 found ... check your connections");
    while (1); // 센서가 없으면 여기서 멈춤
  }
}

void loop() {
  uint16_t r, g, b, c; // Red, Green, Blue, Clear(조도) 값을 담을 변수

  // 센서가 값을 읽을 준비가 될 때까지 잠시 대기
  delay(60);  // integration time(50ms)보다 약간 길게 설정

  // 원시(raw) 데이터 읽기
  tcs.getRawData(&r, &g, &b, &c);
  
  // 원시 데이터를 0-255 범위의 RGB 값으로 변환
  // 조도(c)가 0인 경우를 방지하여 0으로 나누는 오류를 막음
  if (c == 0) {
    return;
  }
  uint8_t red   = (uint8_t)min(255, (int32_t)r * 255 / c);
  uint8_t green = (uint8_t)min(255, (int32_t)g * 255 / c);
  uint8_t blue  = (uint8_t)min(255, (int32_t)b * 255 / c);

  // LAB 값을 저장할 변수
  double L, a, B; // 라이브러리가 double형을 사용

  // RGB를 LAB로 변환
  converter.RgbToLab(red, green, blue, L, a, B);

  // 결과 출력
  Serial.print("RGB: (");
  Serial.print(red);   Serial.print(", ");
  Serial.print(green); Serial.print(", ");
  Serial.print(blue);  Serial.println(")");
  
  Serial.print("LAB: (L=");
  Serial.print(L);     Serial.print(", a=");
  Serial.print(a);     Serial.print(", b=");
  Serial.print(B);     Serial.println(")");
  Serial.println("----------------------------------------");

  delay(1000);
}

// --- 1. 색상 정보를 담을 구조체 정의 ---
// 색상 이름과 기준이 되는 L, a, b 값을 함께 저장합니다.
struct Color {
  const char* name;
  double L, a, b;
};

// --- 2. 기준 색상 목록 (Color Map) ---
// 여기에 색상을 추가하거나 값을 조정하여 정확도를 높일 수 있습니다.
Color colorMap[] = {
  {"빨강 (Red)",    53.24, 80.09, 67.20},
  {"주황 (Orange)", 62.25, 47.98, 72.33},
  {"노랑 (Yellow)", 97.14, -21.55, 94.48},
  {"초록 (Green)",  46.23, -51.70, 49.90},
  {"파랑 (Blue)",   32.30, 79.19, -107.86},
  {"보라 (Purple)", 29.78, 58.97, -36.49},
  {"검정 (Black)",  0.0,   0.0,   0.0},
  {"회색 (Gray)",   53.59, 0.0,   0.0},
  {"하양 (White)",  100.0, 0.0,   0.0}
};
// colorMap 배열의 크기를 계산합니다.
const int numColors = sizeof(colorMap) / sizeof(Color);


// 센서 및 변환기 객체 생성
Adafruit_TCS34725 tcs = Adafruit_TCS34725(TCS34725_INTEGRATIONTIME_50MS, TCS34725_GAIN_4X);
ColorConverter converter;

void setup() {
  Serial.begin(9600);
  Serial.println("Color Recognition Test");

  if (!tcs.begin()) {
    Serial.println("No TCS34725 found ... check connections");
    while (1);
  }
}

void loop() {
  uint16_t r, g, b, c;
  delay(60);
  tcs.getRawData(&r, &g, &b, &c);
  
  if (c == 0) return;
  uint8_t red   = min(255, (uint32_t)r * 255 / c);
  uint8_t green = min(255, (uint32_t)g * 255 / c);
  uint8_t blue  = min(255, (uint32_t)b * 255 / c);

  double L_sensor, a_sensor, b_sensor;
  converter.RgbToLab(red, green, blue, L_sensor, a_sensor, b_sensor);

  // --- 3. 가장 가까운 색상 찾기 ---
  double minDeltaE = 1000.0; // 최소 거리 값을 저장할 변수 (큰 값으로 초기화)
  const char* closestColorName = "Unknown"; // 가장 가까운 색상 이름을 저장할 변수

  for (int i = 0; i < numColors; i++) {
    // 측정된 색과 기준 색 사이의 거리(Delta E) 계산
    double deltaL = L_sensor - colorMap[i].L;
    double deltaA = a_sensor - colorMap[i].a;
    double deltaB = b_sensor - colorMap[i].b;
    double deltaE = sqrt(deltaL * deltaL + deltaA * deltaA + deltaB * deltaB);

    // 계산된 거리가 지금까지의 최소 거리보다 작으면,
    if (deltaE < minDeltaE) {
      minDeltaE = deltaE; // 최소 거리 값을 갱신하고
      closestColorName = colorMap[i].name; // 색상 이름을 저장
    }
  }

  // --- 4. 결과 출력 ---
  Serial.print("RGB: (");
  Serial.print(red);   Serial.print(", ");
  Serial.print(green); Serial.print(", ");
  Serial.print(blue);  Serial.println(")");
  
  Serial.print("LAB: (L=");
  Serial.print(L_sensor, 2); Serial.print(", a=");
  Serial.print(a_sensor, 2); Serial.print(", b=");
  Serial.print(b_sensor, 2); Serial.println(")");

  Serial.print("==> Detected Color: ");
  Serial.println(closestColorName);
  Serial.println("----------------------------------------");

  delay(2000); // 2초 간격으로 측정
}